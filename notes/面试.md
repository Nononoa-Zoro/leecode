### RPC框架

微服务框架一般包含了RPC框架。微服务的核心能力包括

- 基础协议RPC
- 服务发现与注册
- 负载均衡
- 容错
- 熔断
- 限流
- 降级
- 权限
- 全链路日志追踪

#### 基础协议RPC

如何设计一个RPC协议

1. 消息边界

   特殊字符分割，在HTTP和Redis的协议中使用\r\n作为分割符，这种一般要求消息内容是文本内容

   前缀长度，在消息开头增加4字节的整数值，标记消息的长度，适用于二进制的消息

2. 消息结构

   JSON：

   ​	优点：易读

   ​	缺点：冗余，每个字符串都需要用双引号，k/v之前必须要冒号分割，对象必须使用大括号。最大的冗余在于，每次传输的JSON结构都是一样的，消息的结构没有复用。

   pb协议：使用proto格式在代码中定义消息结构，c/s之前只需要传输二进制数据，不需要考虑消息结构。

3. 消息压缩

#### 服务发现与注册

服务端发现模式

#### Golang内存回收

Sweep termination

#### 何时触发GC

源码见gcTrigger

- `gcTriggerHeap` 当前分配的内存达到一定阈值时触发，这个阈值在每次GC过后都会根据堆内存的增长情况和CPU占用率来调整；主要是 [`mallocgc()` ](https://github.com/golang/go/blob/go1.16/src/runtime/malloc.go#L902-L1171)函数,其中分配内存对象大小又分多种情况，建议看下源码实现。
- `gcTriggerTime` 自从上次GC后间隔时间达到了`runtime.forcegcperiod` 时间（默认为2分钟），将启动GC；主要是 `sysmon` 监控线程
- `gcTriggerCycle` 如果当前没有开启垃圾收集，则启动GC；主要是调用函数 `runtime.GC()`

#### 堆和栈

栈：编译器自动分配释放，存放函数的参数值，局部变量值等。大小与生存期确定。

堆：开发者可以动态分配内存大小，存取速度比栈慢。

#### Redis主从模式

主节点负责处理写请求，从节点负责读请求。

#### 主节点宕机，如何在从节点选举一个新的主节点

1. 监控：哨兵进程会定时向所有的主从节点发送PING命令，如果没有在指定时间范围收到回复，便判定当前节点故障。
2. 选主：按照从库优先级打分规则选择分数高的从节点。优先级由高到底：slave-priority数值最低，同步数据最多，runid最小（最新启动的从节点）
3. 通知：将新的主节点信息同步给所有从节点，从节点执行replicaof命令同步数据。另外，最新的主节点信息也会同步到客户端，后续的写请求都会打到新的主节点。

#### KeepAlive

TCP的keepalive是主机和客户端之间的探活机制，一方会不定期的向另一方发送心跳包，如果一方断开，接收方会连续收到RST回包，这个时候发送方会断开链接。如果没有这个机制，如果接收方断开链接，却没有发送FIN包给发送方，那么发送方会一直向一个未监听的端口发送数据。

HTTP的keep-alive，支持在短时间内，多个HTTP请求在一个TCP连接上使用。

### sentinel

sentinel只是一个运行在特殊模式下的Redis服务器

#### 主观下线

监视主服务器的sentinel，在超过timeout之后发现主服务器没有正确应答，此时判定主服务器为主观下线。

#### 客观下线

当sentinel发现被监视的主服务器下线之后，会向其他监视该主服务器的sentinel节点询问，如果超过一半的sentinel认为该主服务器节点下线，此时判定当前主服务器节点客观下线。

### Redis-Pipeline

优点：一次发送多条请求，减少网络传输耗时。

缺点：pipeline模式，Redis服务器必须在返回批量处理结果之前，缓存已处理的请求，所以缓存的请求越多消耗内存越大。

### Redis集群

集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。

### 槽指派

整个集群被划分为16384个槽位

ADDSLOTS 命令为节点绑定槽位

集群中的每个节点都会将自己处理的槽位信息告诉其他的节点，每个节点都知道一个槽位应该由哪个节点处理。

集群中的一个节点在接受到客户端指令的时候，会计算当前键是不是由本节点自己处理，如果是，处理完成后返回，如果不是，返回客户端MOVED，并告诉客户端应该将命令转发给哪个节点。

### 集群节点设置从节点

CLUSTER REPLICATE <node_id> 将当前节点设置为node_id的从节点

#### 集群故障转移

如果在集群中，超过半数以上负责处理槽的主节点都将某个主节点标记为下线，那么这个主节点将被标记为FAIL（下线），并将改节点的下线状态告知给所有的集群。

如果故障节点的从节点收到主节点下线的消息，会从当前节点的所有从节点选择一个执行SLAVEOF NO ONE，该节点升级为主节点。信主节点会撤销所有对已下线节点的槽指派，并将这些全部指向自己。然后向集群中的所有其他节点发送PONG消息，告诉这个节点已经由从节点变为了主节点。

集群模式下的选主的投票权是在所有的处理槽的主节点之中进行的。





#### HTTP GET or POST

|              | GET                                          | POST               |
| ------------ | -------------------------------------------- | ------------------ |
| 刷新和返回   | 不会重新提交表单                             | 重新提交表单       |
| 参数传递位置 | URL                                          | HTTP Body          |
| 数据长度限制 | URL限制最大字符长度2048                      | 无限制             |
| 安全性       | 请求会被浏览器缓存，请求参数明文传输，不安全 | 不会被缓存，更安全 |



### HTTP 状态码

分类

1. 1xx : 信息响应
2. 2xx：成功响应
3. 3xx：重定向
4. 4xx：客户端错误
5. 5xx：服务端错误

301： Moved Permanently 永久性移动，请求的资源已经被永久性移动到新的URL。浏览器会自动重定向。

302： Found 临时移动，请求资源临时移动，客户端继续使用原来的URL。

304： Not Modified，所请求资源未被修改，客户端访问缓存资源。

400： 客户端请求语法错误。

401： Unthorized 未授权。

403： Forbidden 服务端理解了客户端请求，但是拒绝处理。

500： 服务端内部错误，无法完成请求。

502： Bad Gateway，作为网关或者代理服务器尝试执行请求时，从远程服务器接收到一个无效的响应。



### JAVA

#### 基础知识

http://coderleixiaoshuai.gitee.io/java-eight-part/

##### 拆箱和装箱
Integer是int的包装类型
Integer i = 10 // 装箱，调用Integer.valueOf(int i)，产生对应的包装类型
i.intValue()   // 拆箱，返回包装类型对应的基本类型

##### 运行时异常和一般异常的区别？

运行时异常，runtime exception，虚拟机在运行时发生的异常，比如空指针异常，数组访问越界，类型转换失败，出现运行时异常会导致当前线程退出。

一般异常，checked exception，受检异常，JAVA编译器要求我们强制使用try catch捕获这种异常，一般是非程序导致的错误，比如IOException。



##### Error和Exception的区别？

Exception和Error都是继承自Throwable类，JAVA中只有Throwable类可以被throw和catch。Exception是程序在运行过程中，可以预料的意外情况。Error是不可以预测的，比如OOM，线程死锁。



##### 写出常见的五个runtime exception

NullPointerException：空指针异常

ArithmeticException：算术异常

ArrayIndexOutOfBoundsException：数组索引访问越界

ClassCastException：类型转换异常

IllegalArgumentException：非法参数异常



##### Java如何实现线程类

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口
4. 线程池



##### wait和sleep的区别

1. 在使用上：Object.wait Thread.sleep ，wait属于object的方法需要在synchronized所修饰的同步代码块中使用。sleep是Thread的静态方法，用于当前线程让出CPU时间片，强制上下文切换。
2. 锁资源：Object.wait()可以释放当前线程对于object对象锁的持有，sleep不会释放锁资源。
3. 使用场景：sleep一般用于当前线程休眠，wait用于多线程之间通信。



##### 线程的状态

新建：new Thread 此时JVM为线程分配了内存。

就绪：Runnable，new之后start之前，等待CPU时间片分配。

阻塞：Blocked，等待获取对象锁，Thread.sleep()，IO中断。

运行：Running，获取到CPU时间片，开始执行程序。

死亡：运行结束，被回收，释放内存。



### Redis

##### 基本数据结构

String Hash List  Set SortedSet

简单动态字符串SDS
##### Linked List 
```c
// 单个节点定义
typedef struct listNode {
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点的值
    void *value;
}listNode;

// list 方便操作双端链表
typedef struct list {
    listNode *head;
    listNode *tail;
    unsigned long len;
    // 复制节点
    void *(*dup)(void *ptr);
    // 释放节点
    void (*free)(void *ptr);
    // 节点值对比
    int (*match)(void *ptr,void *key);
}
```


##### Redis实现分布式锁

setnx + expire 
setnx的语义是如果不存在这个key，就往Redis写入这个key，expire是设置过期时间。

##### keys和scan

keys阻塞Redis线程，线上查询造成服务卡顿。scan基于游标和模式匹配可以降低Redis服务器查询压力。
scan对key的遍历顺序是”高位+1“，00 10 01 11 ,在缩容的时候存在重复的key遍历，需要客户端自己去重。

##### Hash表

Redis数据库中所有的键值对都存储在Hash表中。

```c
typedef struct dictht {
  dictEntry **table;// 哈希表数组
  unsigned long size;// 哈希表大小
  unsigned long sizemask;// 哈希表大小掩码，值为size-1，用于计算索引值。A%B=A&(B-1)
  unsigned long used;// 哈希表已有节点数量
}dictht;
```

##### 布隆过滤器

目的：在上亿数据的数据集中快速判断给定的一个数据是否存在。

布隆过滤器的本质是长度为m的位向量（仅包含0和1），初始化的时候所有位全部设置为0。

写入：数据写入布隆过滤器，需要提供K个不同的哈希函数，得到K个索引值，在位向量中将这些位置设置为1。

查询：在布隆过滤器中查询某个数据是否存在，需要通过K个哈希函数得到索引值，检查K个索引位置对应位向量中的位置是否为1。如果全部为1，标识该数据”可能存在“。如果K个索引位置对应位向量中的值有一个为0，说明该数据”绝对不存在“。

##### 布隆过滤的误判率FPP

p=(1-(1-1/m)^kn)k

m：位向量大小

n：已添加到m位向量中的个数

k：使用的哈希函数的个数

##### Redis缓存雪崩

场景：在同一时刻大量的key过期，用户请求直接打到DB。比如定时任务将热点数据写入Redis并且设置了相同的过期时间。

解决方案：为这些key设置random的过期时间。

##### Redis缓存穿透

场景：用户请求的数据既不在DB也不在Redis中，这些无效的请求应该被过滤。

解决方案：首先需要在接入层做非法参数校验，其次如果参数合法，但是确实是不存在的数据，可以考虑引入**布隆过滤器**。

##### Redis缓存击穿

场景：热点key访问，有一个热点key持续被大量的用户请求访问，此时突然过期，这样大量用户请求会打到DB。

解决方案：1. 热点key不设置过期时间，占用内存。2. 用户请求到来的时候如果发现Redis缓存里没有这个key，需要申请lock，只有获得锁资源的线程才可以访问DB并刷新缓存，其他线程sleep一段时间，再读取缓存，这样可以保证即便是在热点key失效的情况下也只有一个请求访问DB。

##### 主观下线

sentinel的配置文件中down after milliseconds标识了sentinel判断实例进入主观下线所需要的时间。

##### 客观下线

当sentinel将一个主服务器判断为主观下线之后，它会向其他的sentinel询问判断该主服务器的状态，当sentinel集群超过一半的节点认为该服务器下线后，sentinel会判断当前节点是客观下线状态，并对服务器进行故障转移。

##### 哨兵的作用

集群监控：负责监控master和slave节点是否正常工作。

消息通知：如果有一个Redis实例故障，通知管理员。

故障转移：如果master节点down，自动转移到slave node上。

##### Redis主从模式

主节点提供读写服务并将数据同步到从服务器，从节点提供读写服务，但是在从节点的读操作不会同步到主节点和从节点。

##### Redis过期键删除策略

定时删除：设置键的过期时间的同时为它设置一个定时器，使得在键的过期时间来临时，立即对键执行删除操作。消耗CPU。

惰性删除：放任过期键不管，当用户请求到来时，如果读取的键已经过期，此时再从内存中删除。浪费内存。

定期删除：每个一段时间，程序就对数据库进行一次检测，删除里面过期的键。

##### Redis内存淘汰策略

Noevcition：译为不驱逐，当内存达到限制的时候返回客户端错误。

Allkeys-lru：在所有键空间里，尝试回收最近最少使用的键。

Volatile-lru：在具有过期时间的键空间里，尝试回收最近最少使用的键。

Allkeys-random：在所有键空间里，随机回收键。

Volatile-random：在具有过期时间的键空间里，随机回收键。

Volatile-ttl：在具有过期时间的键空间里，ttl越短越优先被回收。

##### Redis五大数据类型的使用场景

string：

计数器，共享session

hash：

存结构化的数据，比如一个对象

list：

列表型的数据结构，比如粉丝列表，文章的评论列表。

lrange实现高性能的分页查询。

实现简单消息队列。lpush brpop

set:

全局去重

比如两个人的好友，找到公共的好友。

Sortedset：

有序集合，排行榜，延时队列，优先级任务

##### 典型的kv db读写模式

读：先读缓存，如果没有再读DB，将数据更新到缓存中，写rsp返回。

写：写入DB，删除缓存。

##### Redis和memcache的区别

Redis支持复杂的数据结构

Redis原生支持集群模式

##### pipeline

目的：减少client与server的网络传输时延

将多个命令一次性写入Redis服务器，然后等待服务器返回结果，在结果返回之前，Redis服务器会缓存执行结果，所以会增加Redis的内存开销。pipeline所执行的各个命令之间不能有数据依赖关系，因为pipeline不保证命令的顺序执行。

缺点：

由于缓存pipeline执行结果，Redis服务器的内存消耗增加。

pipeline不保证原子性，执行过程中如果一个命令执行失败，也会继续执行剩余的其他命令。

##### pipeline和mget

mget是原子操作

mget是对多个key执行get操作是一条命令，pipeline是多条命令


### Golang
##### new和make的区别
new：起因，指针只能指向一个已经存在的变量，new关键字为变量分配内存并返回指向这个内存的指针。<br>
make：引用类型的初始值为nil，make为引用类型分配内存并初始化。

##### 内存逃逸
###### 什么是内存逃逸
golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。
###### 哪些场景会发生内存逃逸
- 在方法内把局部变量指针返回
- 发送指针或带有指针的值到 channel 中
- 在一个切片上存储指针或带指针的值
- slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )
- 在 interface 类型上调用方法

##### 内存回收

##### 标记-清除（Mark-Sweep)

标记所有”不可达对象“，释放内存。

缺点：标记和清除的过程需要Stop The World

##### 三色标记法

1. 新创建的对象都是白色
2. 从root节点开始遍历
3. 被root直接引用的对象放到灰色集合中
4. 遍历灰色集合，直到灰色集合为空，执行以下操作：将已经遍历过的黑色对象置黑，将灰色对象引用的白色对象置灰。
5. 删除白色对象

##### 三色标记法的问题

如果有黑色对象直接指向白色对象会把白色对象删除，删除了本来需要的对象<br>
灰色到白色对象的引用不能断（弱三色标记法）<br>
黑色到白色对象的引用不能新增（强三色标记法）

##### 强弱三色不变式

强三色不变式：不能存在黑色直接指向白色的引用

弱三色不变式：所有被黑色引用的白色对象必须处于灰色的保护中

##### 插入屏障

在A引用B对象的时候，B对象被标记为灰色

##### 删除屏障

被删除对象，如果自身是白色或者灰色，则被标记为灰色

##### 进程、线程、协程

进程：进程是系统资源分配和调度的最小单位，每个进程都有自己独立的内存空间，由于进程比较重量，上下文切换的开销比较大。

线程：线程是CPU调度的基本单位，是CPU调度的基本单位，

协程：用户态线程，不涉及内核与用户态切换，需要用户实现调度器，让底层线程执行协程



### MySQL

##### 事务的隔离级别

read uncommit：当前事务读取其他事务尚未提交的数据。

read commit：当前事务读取其他事务已经提交的数据。

repeatable read：事务A开始读取数据的时候，事务B不能对数据做任何读写操作。

serialized：事务与事务之间顺序执行。

##### 脏读，不可重复读
脏读：事务A修改了数据但尚未提交，此时事务B可以查询到未提交的事务（读未提交）
不可重复读：事务A读取某行数据，此时事务B正好在修改这行的数据，当事务B提交之后，事务A再次读取该行数据，结果发现前后读取的结果不一致（读已提交）

##### select for update
innodb引擎下，如果where条件语句中的字段是主键或加了索引的列，则锁定当前行，否则锁定表。

##### in和exists的区别
```sql
select * from A where deptId in (select deptId from B);
先做子查询再用子查询结果去主查询执行，等价于以下伪代码
for i in B 
    for j in A 
        if B[i]==A[j]
            res.add(B[i])
select * from A where deptId exists (select deptId from B)
先做主查询再做子查询
for i in A
    for j in B
        if B[i]==A[j]
            res.add(B[i])
```

##### Union和Union All

MYSQL Union操作符，用于连接两个以上的SELECT结果集到一个结果集中，Union自带去重功能。

Union All不会去重。

##### Innodb和Myisam的区别

innodb支持事务，myisam不支持事务

innodb支持行级锁，myisam支持表级锁

innodb支持MVCC，myisam不支持

innodb支持外键，myisam不支持

innodb不支持全文索引，myisam不支持

##### mysql innodb引擎如何实现数据一致性

Redo log：在mysql中日志可以分为，物理日志，逻辑日志。redo log是一种物理日志，记录的是磁盘上数据页的数据变化。mysql在将数据写入磁盘之前会先写redo log，master thread会在每个checkpoint来临的时候，将redo log中的数据刷新到磁盘的数据页中。

redo log写入磁盘的策略：innodb_flush_log_at_trx_commit

1：表示提交事务的时候，必须调一次fsync参数，将内存中缓冲数据刷新到磁盘。

0：提交事务不写磁盘，写入过程在master thread执行。

2：事务提交时不写重做日志文件，而是写入文件系统缓冲中。

##### mysql的基本数据类型

**整型**：TINYINT(1) SMALLNT(2) MEDIUMINT(3) INT(4) BIGINT(8)

整型写法 int(N)，只要是int就是4个字节，括号中的N表示终端显示的长度，比如int(10)，如果该数不足10位且设置了unsigned zerofill的话，左边高位会补0。如果超过了10位会按照真实的数据长度显示。

**浮点型**：float（4）double（8）decimal

**日期类型**：date time year datetime timestamp

datetime占8个字节，时间范围1000-01-01 00:00:00——9999-12-31 23:59:59，默认为空，插入的时候该列的值为空那就为null。与时区无关。

timestamp占4个字节，时间范围19700101080001——20380119111407，默认不为空，当插入null值的时候，MYSQL会取当前时间戳作为该列的值。依赖当前时区。

##### SQL注入如何解决？为什么预编译可以解决？

使用？当占位符，在操作数据库之前SQL语句已经被解析，编译和优化，此时已经生成了执行计划，程序运行时，参数会动态传递给PrepareStatement而不会分析其SQL语法，传入的值都当做字面量处理。

##### MYSQL索引失效有哪些场景？

如何判断索引失效了：explain在extra列看到using where

1. 违反最左前缀规则：如果索引有多列，需要满足最左前缀规则。
2. 在索引列上做任何操作：比如计算，函数，类型转换等。
3. 联合索引，中间用了范围查询。
4. where条件中使用!=,<>。
5. 字符串列索引以通配符开头的like '%abc'。
6. where子句使用or。
7. order by，group by子句未满足索引的最左前缀规则。





### 一致性hash

问题：分布式场景下，对于分布式缓存，由于服务器节点扩缩容，导致路由key的映射规则失效，如果同一时间大量的key失效会造成“缓存雪崩”。

一致性hash算法，是一种特殊的hash算法，是在移除或者添加一个服务器的时候，尽可能小的改变已经存在的服务请求与服务处理器之间的映射关系。一致性hash解决了，简单hash算法在分布式hash表中的动态伸缩等问题。

一致性哈希的缺点：如果将真实机器ip作为key放在hash环中，新增节点的时候只能减少某一个机器的请求压力。可以使用虚拟节点的方式，放在哈希环上的都是虚拟节点，对应多个真实的节点。















